// 
// Decompiled by Procyon v0.5.36
// 

package app.display.dialogs.editor;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public final class EditorHelpData
{
    private static final EditorHelpData SINGLETON;
    private static final String RESOURCE_PATH = "/help/EditorHelp.txt";
    private final Map<String, String> typeDocStrings;
    private final Map<String, List<String>> constructorLines;
    private final Map<String, List<List<String>>> constructorParamLines;
    private final Map<String, List<List<String>>> constructorExampleLines;
    private final Map<String, String> defineDocStrings;
    private final Map<String, List<String>> defineExampleLines;
    private final Map<String, List<String>> enumConstantLines;
    private final Map<String, List<String>> subclassDocLines;
    private final Map<String, String> typeRemarksStrings;
    
    private EditorHelpData(final Map<String, String> typeDocStrings, final Map<String, List<String>> constructorLines, final Map<String, List<List<String>>> constructorParamLines, final Map<String, List<List<String>>> constructorExampleLines, final Map<String, String> defineDocStrings, final Map<String, List<String>> defineExampleLines, final Map<String, List<String>> enumConstantLines, final Map<String, List<String>> subclassDocLines, final Map<String, String> typeRemarksStrings) {
        this.typeDocStrings = typeDocStrings;
        this.constructorLines = constructorLines;
        this.constructorParamLines = constructorParamLines;
        this.constructorExampleLines = constructorExampleLines;
        this.defineDocStrings = defineDocStrings;
        this.defineExampleLines = defineExampleLines;
        this.enumConstantLines = enumConstantLines;
        this.subclassDocLines = subclassDocLines;
        this.typeRemarksStrings = typeRemarksStrings;
    }
    
    public static EditorHelpData get() {
        return EditorHelpData.SINGLETON;
    }
    
    public String nthConstructorLine(final String type, final int n) {
        return this.constructorLines.get(type).get(n);
    }
    
    public List<String> nthConstructorParamLines(final String type, final int n) {
        return this.constructorParamLines.get(type).get(n);
    }
    
    public List<String> nthConstructorExampleLines(final String type, final int n) {
        return this.constructorExampleLines.get(type).get(n);
    }
    
    public int numConstructors(final String type) {
        final List<String> lines = this.constructorLines.get(type);
        if (lines == null) {
            System.out.println("Lines not found for " + type);
        }
        return (lines == null) ? 0 : lines.size();
    }
    
    public List<String> enumConstantLines(final String type) {
        return this.enumConstantLines.get(type);
    }
    
    public List<String> subclassDocLines(final String type) {
        return this.subclassDocLines.get(type);
    }
    
    public String typeDocString(final String type) {
        return this.typeDocStrings.get(type);
    }
    
    public String typeRemarksString(final String type) {
        return this.typeRemarksStrings.get(type);
    }
    
    public String defineDocString(final String defineName) {
        return this.defineDocStrings.get(defineName);
    }
    
    public List<String> defineExampleLines(final String defineName) {
        return this.defineExampleLines.get(defineName);
    }
    
    private static EditorHelpData loadData() {
        final Map<String, String> typeDocStrings = new HashMap<>();
        final Map<String, List<String>> constructorLines = new HashMap<>();
        final Map<String, List<List<String>>> constructorParamLines = new HashMap<>();
        final Map<String, List<List<String>>> constructorExampleLines = new HashMap<>();
        final Map<String, String> defineDocStrings = new HashMap<>();
        final Map<String, List<String>> defineExampleLines = new HashMap<>();
        final Map<String, List<String>> enumConstantLines = new HashMap<>();
        final Map<String, List<String>> subclassDocLines = new HashMap<>();
        final Map<String, String> typeRemarksStrings = new HashMap<>();
        final Map<String, List<String>> subclasses = new HashMap<>();
        try (final InputStream resource = EditorHelpData.class.getResourceAsStream("/help/EditorHelp.txt")) {
            if (resource == null) {
                System.err.println("Cannot locate resource /help/EditorHelp.txt - not all functionality will be available.\nThis file can be generated by running the\n main method of LudiiDocGen/main/GenerateLudiiEditorHelpFileMain.java");
                return new EditorHelpData(typeDocStrings, constructorLines, constructorParamLines, constructorExampleLines, defineDocStrings, defineExampleLines, enumConstantLines, subclassDocLines, typeRemarksStrings);
            }
            try (final InputStreamReader isr = new InputStreamReader(resource);
                 final BufferedReader rdr = new BufferedReader(isr)) {
                String currType = null;
                int currConstructor = -1;
                String currDefine = null;
                String line;
                while ((line = rdr.readLine()) != null) {
                    if (line.startsWith("TYPE: ")) {
                        currType = line.substring("TYPE: ".length());
                        constructorLines.put(currType, new ArrayList<>());
                        constructorParamLines.put(currType, new ArrayList<>());
                        constructorExampleLines.put(currType, new ArrayList<>());
                        currConstructor = -1;
                    }
                    else if (line.startsWith("TYPE JAVADOC: ")) {
                        typeDocStrings.put(currType, line.substring("TYPE JAVADOC: ".length()));
                    }
                    else if (line.equals("NEW CTOR")) {
                        ++currConstructor;
                        constructorParamLines.get(currType).add(new ArrayList<>());
                        constructorExampleLines.get(currType).add(new ArrayList<>());
                    }
                    else if (line.startsWith("PARAM JAVADOC: ")) {
                        constructorParamLines.get(currType).get(currConstructor).add(line.substring("PARAM JAVADOC: ".length()));
                    }
                    else if (line.startsWith("EXAMPLE: ")) {
                        constructorExampleLines.get(currType).get(currConstructor).add(line.substring("EXAMPLE: ".length()));
                    }
                    else if (line.startsWith("DEFINE: ")) {
                        currDefine = line.substring("DEFINE: ".length());
                        defineExampleLines.put(currDefine, new ArrayList<>());
                    }
                    else if (line.startsWith("DEFINE JAVADOC: ")) {
                        defineDocStrings.put(currDefine, line.substring("DEFINE JAVADOC: ".length()));
                    }
                    else if (line.startsWith("DEFINE EXAMPLE: ")) {
                        defineExampleLines.get(currDefine).add(line.substring("DEFINE EXAMPLE: ".length()));
                    }
                    else if (line.startsWith("CONST JAVADOC: ")) {
                        if (!enumConstantLines.containsKey(currType)) {
                            enumConstantLines.put(currType, new ArrayList<>());
                        }
                        enumConstantLines.get(currType).add(line.substring("CONST JAVADOC: ".length()));
                    }
                    else if (line.startsWith("SUBCLASS: ")) {
                        if (!subclasses.containsKey(currType)) {
                            subclasses.put(currType, new ArrayList<>());
                        }
                        subclasses.get(currType).add(line.substring("SUBCLASS: ".length()));
                    }
                    else if (line.startsWith("REMARKS: ")) {
                        typeRemarksStrings.put(currType, line.substring("REMARKS: ".length()));
                    }
                    else {
                        constructorLines.get(currType).add(line);
                    }
                }
            }
        }
        catch (IOException e) {
            e.printStackTrace();
        }
        for (final Map.Entry<String, List<String>> entry : subclasses.entrySet()) {
            final String abstractType = entry.getKey();
            final List<String> subclassTypes = entry.getValue();
            final List<String> docLines = new ArrayList<>(subclassTypes.size());
            for (final String subclassType : subclassTypes) {
                String typeDoc = typeDocStrings.get(subclassType);
                if (typeDoc == null) {
                    typeDoc = "";
                    System.err.println("WARNING: no type doc for subclass " + subclassType + " of abstract type " + abstractType + "!");
                }
                docLines.add("<" + subclassType + "> : " + typeDoc);
            }
            subclassDocLines.put(abstractType, docLines);
        }
        return new EditorHelpData(typeDocStrings, constructorLines, constructorParamLines, constructorExampleLines, defineDocStrings, defineExampleLines, enumConstantLines, subclassDocLines, typeRemarksStrings);
    }
    
    static {
        SINGLETON = loadData();
    }
}
